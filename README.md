Download Link: https://assignmentchef.com/product/solved-csci567-homework-5-hidden-markov-models
<br>
In this problem, we want to fit DNA sequence data with a generative model. In particular, we assume that they are generated by a hidden Markov model (HMM). Let <strong>X</strong><sub>1:<em>N </em></sub>= [<em>X</em><sub>1</sub><em>X</em><sub>2 </sub><em>…X<sub>N</sub></em>] be random variables corresponding to a DNA sequence of length <em>N</em>, controlled by hidden states <strong>Z</strong><sub>1:<em>N </em></sub>= [<em>Z</em><sub>1</sub><em>Z</em><sub>2 </sub><em>…Z<sub>N</sub></em>]. Each <em>X<sub>n </sub></em>takes a value in {<em>A,C,G,T</em>} and each <em>Z<sub>n </sub></em>takes one of the two possible states {<em>s</em><sub>1</sub><em>,s</em><sub>2</sub>}. This HMM has the following parameters <strong>Θ </strong>= {<em>π<sub>i</sub>,a<sub>ij</sub>,b<sub>ik</sub></em>} for <em>i </em>∈ {1<em>,</em>2}, <em>j </em>∈ {1<em>,</em>2}, and <em>k </em>∈ {<em>A,C,G,T</em>}:

<ul>

 <li>Initial state distribution <em>π<sub>i </sub></em>for <em>i </em>= 1<em>,</em>2:</li>

</ul>

<em>π</em><sub>1 </sub>= <em>P</em>(<em>Z</em><sub>1 </sub>= <em>s</em><sub>1</sub>) = 0<em>.</em>7;              <em>π</em><sub>2 </sub>= <em>P</em>(<em>Z</em><sub>1 </sub>= <em>s</em><sub>2</sub>) = 0<em>.</em>3<em>.                                            </em>(1)

<ul>

 <li>Transition probabilities <em>a<sub>ij </sub></em>= <em>P</em>(<em>Z<sub>n</sub></em><sub>+1 </sub>= <em>s</em><sub>1</sub>|<em>Z<sub>n </sub></em>= <em>s<sub>i</sub></em>) for any <em>n </em>∈ N<sup>+</sup><em>,i </em>= 1<em>,</em>2 and <em>j </em>= 1<em>,</em>2:</li>

</ul>

<em>a</em><sub>11 </sub>= 0<em>.</em>8<em>,        a</em><sub>12 </sub>= 0<em>.</em>2<em>,        a</em><sub>21 </sub>= 0<em>.</em>4<em>,        a</em><sub>22 </sub>= 0<em>.</em>6<em>.                                           </em>(2)

<ul>

 <li>Emission probabilities <em>b<sub>ik </sub></em>= <em>P</em>(<em>X<sub>n </sub></em>= <em>k</em>|<em>Z<sub>n </sub></em>= <em>s<sub>i</sub></em>) for any <em>n </em>∈ N<sup>+</sup><em>,i </em>= 1<em>,</em>2 and <em>k </em>∈ {<em>A,C,G,T</em>}:</li>

</ul>

<table width="0">

 <tbody>

  <tr>

   <td width="80"><em>b</em><sub>1<em>A </em></sub>= 0<em>.</em>4<em>,</em></td>

   <td width="80"><em>b</em><sub>1<em>C </em></sub>= 0<em>.</em>1<em>,</em></td>

   <td width="75"><em>b</em><sub>1<em>G </em></sub>= 0<em>.</em>4<em>,</em></td>

   <td width="114"><em>b</em><sub>1<em>T </em></sub>= 0<em>.</em>1;</td>

   <td width="95">(3)</td>

  </tr>

  <tr>

   <td width="80"><em>b</em><sub>2<em>A </em></sub>= 0<em>.</em>2<em>,</em></td>

   <td width="80"><em>b</em><sub>2<em>C </em></sub>= 0<em>.</em>3<em>,</em></td>

   <td width="75"><em>b</em><sub>2<em>G </em></sub>= 0<em>.</em>2<em>,</em></td>

   <td width="114"><em>b</em><sub>2<em>T </em></sub>= 0<em>.</em>3<em>.</em></td>

   <td width="95">(4)</td>

  </tr>

 </tbody>

</table>

We observe a sequence <strong>O</strong><sub>1:6 </sub>= [<em>o</em><sub>1</sub><em>o</em><sub>2 </sub><em>…o</em><sub>6</sub>] = [<em>AGCGTA</em>], please answer the following questions with step-by-step computations.

<strong>Q1.1 Probability of an observed sequence              </strong>Compute <em>P</em>(<strong>X</strong><sub>1:6 </sub>= <strong>O</strong><sub>1:6</sub>;<strong>Θ</strong>).

<strong>Q1.2 Most likely explanation            </strong>Compute <em>z</em><em>    </em>] = argmax<em><sub>z</sub></em><sub>1:6 </sub><em>P</em>(<em>Z</em><sub>1:6 </sub>= <em>z</em><sub>1:6</sub>|<strong>X</strong><sub>1:6 </sub>=

<strong>O</strong><sub>1:6</sub>;<strong>Θ</strong>).

<strong>Q1.3 Prediction                </strong>Compute <em>x</em><sup>∗ </sup>= argmax<em><sub>x </sub>P</em>(<em>X</em><sub>7 </sub>= <em>x</em>|<strong>X</strong><sub>1:6 </sub>= <strong>O</strong><sub>1:6</sub>;<strong>Θ</strong>).

<em>What to submit: </em>Mathematical derivations and numerical results for each of the problems above. You should derive them manually.

<strong>Reminder: </strong>Do not have any spaces in your filename. If you are considering putting a space, put an underscore instead. Do not have more than one PDF file in your homework5 directory.

<strong>Programming component</strong>

<h1>2           High-level descriptions</h1>

<h2>2.1         Datasets</h2>

In Sect. 3, we will play with a small hidden Markov model. The parameters of the model are given in hmm model.json. In Sect. 4, you will perform dimensionality reduction and visualize a subset of <strong>MNIST</strong>: 784-dimensional feature vectors in mnist2500 X.txt and their corresponding labels in mnist2500 labels.txt.

<h2>2.2         Tasks</h2>

You will be asked to implement hidden Markov model (HMM) inference procedures and the tdistributed stochastic neighbor embedding (t-SNE) algorithm. Specifically, you will

<ul>

 <li>For Sect. 3: Finish implementing the function forward, backward, seqprob forward, seqprob backward, and viterbi. Refer to py for more information.</li>

 <li>For Sect. 4: Finish implementing the function pca, compute Q and compute gradient. Refer to py for more information.</li>

 <li>Run the scripts sh, pca.sh, and tsne.sh after you finish your implementation. hmm.sh will output hmm.txt. pca.sh will output pca.npy. tsne.sh will show visualization of the dataset and will also output Y.npy.</li>

 <li>Add, commit, and push py and tsne.py, and the files that you have generated.</li>

</ul>

As in the previous homework, you are not responsible for loading/pre-processing data.

<h2>2.3         Cautions</h2>

Please do not import packages that are not listed in the provided code. Follow the instructions in each section strictly to code up your solutions. <strong>Do not change the output format</strong>. <strong>Do not modify the code unless we instruct you to do so</strong>. A homework solution that does not match the provided setup, such as format, name, initializations, etc., <strong>will not </strong>be graded. It is your responsibility to <strong>make sure that your code runs with the provided commands and scripts on the VM</strong>. Finally, make sure that you <strong>git add, commit, and push all the required files</strong>, including your code and generated output files.

<h1>3           Hidden Markov Models</h1>

In this problem, you are given parameters of a small hidden Markov model and you will implement three inference procedures, similar to what you have done manually in the first question. In hmm model.json, you will find the following model parameters:

<ul>

 <li><em>π</em>: the initial probabilities, <em>π<sub>i </sub></em>= <em>P</em>(<em>Z</em><sub>1 </sub>= <em>s<sub>i</sub></em>);</li>

 <li><em>A</em>: the transition probabilities, with <em>a<sub>ij </sub></em>= <em>P</em>(<em>Z<sub>t </sub></em>= <em>s<sub>j</sub></em>|<em>Z<sub>t</sub></em><sub>−1 </sub>= <em>s<sub>i</sub></em>);</li>

 <li><em>B</em>: the observation probabilities, with <em>b<sub>ik </sub></em>= <em>P</em>(<em>X<sub>t </sub></em>= <em>o<sub>k</sub></em>|<em>Z<sub>t </sub></em>= <em>s<sub>i</sub></em>).</li>

</ul>

Now we observe a sequence <em>O </em>of length <em>L</em>. Your task is to write code to compute probabilities and infer about the possible hidden states given this observation. In particular, first in <strong>Q3.1 </strong>and <strong>Q3.2</strong>, we want to compute <em>P</em>(<em>x</em><sub>1</sub><em>,…,x<sub>L </sub></em>= <em>O</em>), the probability of observing the sequence. You should use the forward algorithm and the backward algorithm to achieve that. Then in <strong>Q3.3</strong>, we infer the most likely state path. Note that your code might be tested against different parameter sets/observation sequences at grading time.

<strong>Q3.1           </strong>Please finish the implementation of the functions forward() and backward() in hmm.py:

<ul>

 <li>forward(<em>π,A,B,O</em>) takes the model parameters <em>π,A,B </em>and the observation sequence <em>O </em>as input and output a numpy array <em>α</em>, where <em>α</em>[<em>j,t</em>] = <em>α<sub>t</sub></em>(<em>j</em>) = <em>P</em>(<em>Z<sub>t </sub></em>= <em>s<sub>j</sub>,x</em><sub>1:<em>t</em></sub>).</li>

 <li>backward(<em>π,A,B,O</em>) takes the model parameters <em>π,A,B </em>and the observation sequence <em>O </em>as input and output a numpy array <em>β</em>, where <em>β</em>[<em>j,t</em>] = <em>β<sub>t</sub></em>(<em>j</em>) = <em>P</em>(<em>Z<sub>t </sub></em>= <em>s<sub>j</sub>,x<sub>t</sub></em><sub>+1:<em>T</em></sub>).</li>

</ul>

Please follow the slides 35, 36 in lec18.pdf for your implementation.

<strong>Q3.2 </strong>Now we can calculate <em>P</em>(<em>x</em><sub>1</sub><em>,…,x<sub>L </sub></em>= <em>O</em>) from the output of your forward and backward algorithms. Please finish the implementation of the function seqprob forward() and seqprob backward() in hmm.py. Both of them should return <em>P</em>(<em>x</em><sub>1</sub><em>,…,x<sub>L </sub></em>= <em>O</em>).

<strong>Q3.3             </strong>We want to compute the most likely state path that corresponds to the observation <em>O</em>.

Namely,

<em>k</em><em>          </em>) = argmax<em><sub>k </sub>P</em>(<em>s<sub>k</sub></em><sub>1</sub><em>,s<sub>k</sub></em><sub>2</sub><em>,</em>··· <em>,s<sub>k</sub></em><em><sub>L</sub></em>|<em>x</em><sub>1</sub><em>,x</em><sub>2</sub><em>,</em>··· <em>,x<sub>L </sub></em>= <em>O</em>)<em>.</em>

Please implement the Viterbi algorithm in viterbi() in hmm.py. The function viterbi(<em>π,A,B,O</em>) takes the model parameters <em>π,A,B </em>and the observation sequence <em>O </em>as input and output a list path which contains the most likely state path <em>k</em><sup>∗ </sup>(in terms of the state index) you have found.

<em>What to do and submit: </em>After you finish each task in Q3.1/3.2 and Q3.3 in hmm.py, run the script hmm.sh. It will generate hmm.txt. Add, commit, and push both hmm.py and hmm.txt before the due date.

<h1>4           Dimensionality Reduction</h1>

In this question, you will implement t-Distributed Stochastic Neighbor Embedding (t-SNE) [1], a (prize-winning) technique for dimensionality reduction that is particularly well suited for the visualization of high-dimensional datasets. t-SNE maps high-dimensional data points <em>x</em><sub>1</sub><em>,x</em><sub>2</sub><em>,…,x<sub>N </sub></em>into two or three-dimensional <em>embeddings y</em><sub>1</sub><em>,y</em><sub>2</sub><em>,…,y<sub>N </sub></em>that can be displayed in a scatter plot. Unlike PCA that you learned in class, t-SNE is a <em>non-linear </em>dimensionality reduction technique. It is widely used (more than 3,300 citations and counting). If you are curious about how to use it effectively, check this out <a href="https://distill.pub/2016/misread-tsne/">https://distill.pub/2016/misread-tsne/</a><a href="https://distill.pub/2016/misread-tsne/">.</a>

Intuitively, we want the low-dimensional data points to reflect similarities of their corresponding data points in the high-dimensional space. In other words, after applying the mapping, similar data points are still near each other and dissimilar data points are still far apart. In t-SNE, this is achieved in two steps. First, t-SNE constructs a joint probability distribution <em>P </em>over pairs of highdimensional data points in such a way that similar points have a high probability of being picked, whilst dissimilar points have an extremely small probability. Second, t-SNE similarly defines a joint probability distribution <em>Q </em>over pairs of low-dimensional data points and then minimizes the Kullback-Leibler (KL) divergence between <em>P </em>and <em>Q</em>. You could think of KL-divergence as a measure of how one probability distribution diverges from another.

Formally, let <em>p<sub>ij </sub></em>= <em>P</em>(<em>x<sub>i</sub>,x<sub>j</sub></em>) and <em>q<sub>ij </sub></em>= <em>Q</em>(<em>x<sub>i</sub>,x<sub>j</sub></em>). Then, we minimize

<em>,                                                             </em>(5)

where we define each of the above terms below. Please refer to the original paper [1] for justifications of their choice of probability distributions as well as their choice of objective.

We define the pairwise similarities <em>p<sub>ij </sub></em>between <em>x<sub>i </sub></em>and <em>x<sub>j </sub></em>in the high-dimensional space as

<em>,</em>where<em>.                                             </em>(6)

where <em>σ<sub>i</sub></em><sup>2 </sup>is the variance of a Gaussian distribution that is centered at <em>x<sub>i</sub></em>. The conditional probability <em>p<sub>j</sub></em><sub>|<em>i </em></sub>could be interpreted as the probability of <em>x<sub>i </sub>picking x<sub>j </sub></em>as its neighbor.

Moreover, we define the pairwise similarities <em>q<sub>ij </sub></em>between <em>y<sub>i </sub></em>and <em>y<sub>j </sub></em>in the low-dimensional space with a Student t-distribution with one degree of freedom:

<em>.                                                                  </em>(7)

Finally, we set both <em>p<sub>ii </sub></em>and <em>q<sub>ii </sub></em>to zeros, as we are only interested in pairwise similarities.

We use gradient descent to minimize the cost function in Eq. (5). The gradient is given by

<em>.                                               </em>(8)

(Can you verify that this is indeed the formula for the gradient?)

<strong>Q4.1 </strong>We first apply PCA to our very high-dimensional data points. This in practice helps speed up the computation and reduce noise in the data points before we apply t-SNE. Finish the implementation of PCA in function pca in tsne.py to map the data points of dimensionality 784 to 50.

<em>What to do and submit: </em>Finish the implementation of function pca. Run the script pca.sh. It will output a file pca.npy. Add, commit and push the pca.npy and your modified tsne.py before the due date.

<strong>Q4.2 </strong>After PCA, finish the implementation of the t-SNE algorithm. In tsne.py, you are given the code to compute <em>p<sub>ij</sub></em>, and you need to finish the code that computes <em>q<sub>ij </sub></em>in function compute Q. You may need to refer to Eq. (7).

<em>What to do and submit: </em>Finish the implementation of function compute Q. Add, commit, and push the modified your modified tsne.py before due date.

<strong>Q4.3 </strong>Compute the gradient using Eq. (8) in function compute gradient in tsne.py. Finally, running the script tsne.sh will show cool t-SNE visualization the data in the 2-dimensional space.

<em>What to do and submit: </em>Finish the implementation of function compute gradient. Run the script tsne.sh. It will output a file Y.npy. Add, commit and push Y.npy and your modified tsne.py before due date.

<strong>Note: </strong>Feel free look at the Matlab implementation of t-SNE at <a href="https://lvdmaaten.github.io/tsne/code/tSNE_matlab.zip">https://lvdmaaten.github. </a><a href="https://lvdmaaten.github.io/tsne/code/tSNE_matlab.zip">io/tsne/code/tSNE_matlab.zip</a><a href="https://lvdmaaten.github.io/tsne/code/tSNE_matlab.zip">,</a> but you are not permitted to look at any other online implementation of t-SNE, here and elsewhere.